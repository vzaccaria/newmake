// Generated by LiveScript 1.3.1
(function(){
  "use strict";
  var TreeModel, debug, uid, _, tree, emptyNode, mapProducts, getAllProducts, getTargetsConditional, getPhonyTargets, getAllTargets, removeFirst, removeAll, treeBuilder, parse;
  TreeModel = require('tree-model');
  debug = require('debug')('tree');
  uid = require('uid');
  _ = require('lodash');
  tree = new TreeModel();
  emptyNode = function(){
    return tree.parse({});
  };
  mapProducts = function(r){
    return r.walk({
      strategy: 'post'
    }, function(node){
      var products;
      products = [];
      return (function(){
        var ref$, buildFrom, res$, i$, len$, s, prod, build, this$ = this;
        if ((ref$ = this.type) === "compile" || ref$ === "process" || ref$ === "move") {
          if (this.type === "process" || this.type === "move") {
            this.sources = _.flatten(this.children.map(function(it){
              return it.products;
            }));
          }
          if (this.type === "move") {
            if (this.options.strip == null) {
              this.productFun = function(s){
                return this.destination + "/" + s.source;
              };
            } else {
              this.productFun = function(s){
                return this.destination + "/" + s.source.replace(this.options.strip, "");
              };
            }
            this.cmdFun = function(_){
              return "cp " + _.source + " " + _.product;
            };
          }
          buildFrom = function(it){
            var prod;
            prod = this$.productFun({
              source: it
            });
            return {
              command: this$.cmdFun({
                source: it,
                product: prod
              }),
              product: prod,
              source: it,
              deps: this$.deps
            };
          };
          res$ = [];
          for (i$ = 0, len$ = (ref$ = _.flatten(this.sources)).length; i$ < len$; ++i$) {
            s = ref$[i$];
            res$.push(buildFrom(s));
          }
          this.builds = res$;
          this.products = _.map(this.builds, function(it){
            return it.product;
          });
        }
        if (this.type === "reduce") {
          this.sources = _.flatten(this.children.map(function(it){
            return it.products;
          }));
          prod = this.productFun({});
          build = {
            command: this.cmdFun({
              sources: this.sources,
              product: prod
            }),
            product: prod,
            deps: this.sources
          };
          this.products = [build.product];
          this.builds = [build];
        }
        if (this.type === "root") {
          return this.products = _.flatten(this.children.map(function(it){
            return it.products;
          }));
        }
      }.call(node.model));
    });
  };
  getAllProducts = function(r){
    var prod;
    mapProducts(r);
    prod = {};
    r.walk({
      strategy: 'post'
    }, function(node){
      return (function(){
        var i$, ref$, len$, p, results$ = [];
        for (i$ = 0, len$ = (ref$ = this.products).length; i$ < len$; ++i$) {
          p = ref$[i$];
          results$.push(prod[p] = true);
        }
        return results$;
      }.call(node.model));
    });
    return _.keys(prod);
  };
  getTargetsConditional = function(r, c){
    var targets;
    targets = {};
    r.walk({
      strategy: 'post'
    }, function(node){
      return (function(){
        var names;
        if (c(this)) {
          names = _.flatten(this.children.map(function(it){
            return it.targetName;
          }));
          return targets[this.targetName] = names;
        }
      }.call(node.model));
    });
    return targets;
  };
  getPhonyTargets = function(r){
    return getTargetsConditional(r, function(it){
      return it.type === "collect";
    });
  };
  getAllTargets = function(r){
    return r.all(function(it){
      return it.type !== "collect";
    });
  };
  removeFirst = function(root, condition){
    var x, father, i$, ref$, len$, c;
    x = root.first(condition);
    if (x != null && x.model.targetName !== root.targetName) {
      father = x.parent;
      for (i$ = 0, len$ = (ref$ = x.children).length; i$ < len$; ++i$) {
        c = ref$[i$];
        father.addChild(c);
      }
      x.drop();
      return true;
    } else {
      return false;
    }
  };
  removeAll = function(root, condition){
    var results$ = [];
    do {
      results$.push(null);
    } while (removeFirst(root, condition));
    return results$;
  };
  treeBuilder = (function(){
    treeBuilder.displayName = 'treeBuilder';
    var prototype = treeBuilder.prototype, constructor = treeBuilder;
    function treeBuilder(){
      this.addPack = bind$(this, 'addPack', prototype);
      this.parse = bind$(this, 'parse', prototype);
      this.collectSeq = bind$(this, 'collectSeq', prototype);
      this.mirrorTo = bind$(this, 'mirrorTo', prototype);
      this.collect = bind$(this, 'collect', prototype);
      this._collect = bind$(this, '_collect', prototype);
      this.reduceFiles = bind$(this, 'reduceFiles', prototype);
      this.processFiles = bind$(this, 'processFiles', prototype);
      this.compileFiles = bind$(this, 'compileFiles', prototype);
      this.createTree = bind$(this, 'createTree', prototype);
      this.curNode = emptyNode();
      this.curNode.model.targetName = "root";
      this.curNode.model.type = "root";
    }
    prototype.createTree = function(body){
      var newNode, savedCurNode;
      newNode = emptyNode();
      savedCurNode = this.curNode;
      this.curNode = newNode;
      body.apply(this, [this]);
      this.curNode = savedCurNode;
      debug(newNode);
      newNode.model.children = newNode.children.map(function(it){
        return it.model;
      });
      return newNode;
    };
    prototype.compileFiles = function(cmd, product, src, deps){
      src = [src];
      deps == null && (deps = []);
      return this.curNode.addChild(tree.parse({
        cmdFun: cmd,
        productFun: product,
        sources: src,
        deps: deps,
        targetName: "c-" + uid(8),
        type: "compile",
        children: []
      }));
    };
    prototype.processFiles = function(cmd, product, body){
      var root;
      root = this.createTree(body);
      _.extend(root.model, {
        cmdFun: cmd,
        productFun: product,
        targetName: "p-" + uid(8),
        type: "process",
        deps: []
      });
      return this.curNode.addChild(root);
    };
    prototype.reduceFiles = function(cmd, product, body){
      var root;
      root = this.createTree(body);
      _.extend(root.model, {
        cmdFun: cmd,
        productFun: product,
        targetName: "r-" + uid(8),
        type: "reduce",
        deps: []
      });
      return this.curNode.addChild(root);
    };
    prototype._collect = function(name, body, options){
      var root;
      debug("Creating " + name);
      root = this.createTree(body);
      _.extend(root.model, {
        targetName: name,
        options: options,
        type: "collect"
      });
      return this.curNode.addChild(root);
    };
    prototype.collect = function(name, body){
      return this._collect(name, body, {});
    };
    prototype.mirrorTo = function(name, options, body){
      var root;
      if (_.isFunction(options)) {
        body = options;
        options = {};
      }
      root = this.createTree(body);
      _.extend(root.model, {
        type: "move",
        options: options,
        destination: name,
        targetName: "m-" + uid(8),
        deps: []
      });
      return this.curNode.addChild(root);
    };
    prototype.collectSeq = function(name, body){
      return this._collect(name, body, {
        sequential: true
      });
    };
    prototype.parse = function(body){
      this.curNode = this.createTree(body);
      _.extend(this.curNode.model, {
        targetName: "root",
        type: "root"
      });
      this.phonyTargets = getPhonyTargets(this.curNode);
      removeAll(this.curNode, function(n){
        return n.model.type === "collect";
      });
      this.allProducts = getAllProducts(this.curNode);
      this.allTargets = getAllTargets(this.curNode);
      return this.root = this.curNode;
    };
    prototype.addPack = function(pack){
      var k, v, results$ = [];
      for (k in pack) {
        v = pack[k];
        results$.push(this[k] = v.bind(this));
      }
      return results$;
    };
    return treeBuilder;
  }());
  parse = function(body){
    var tb;
    tb = new treeBuilder();
    tb.parse(body);
    return tb;
  };
  module.exports = {
    parse: parse
  };
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
