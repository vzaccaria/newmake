// Generated by LiveScript 1.3.1
(function(){
  "use strict";
  var TreeModel, debug, uid, _, tree, emptyNode, treeBuilder, parse, removeFirst, removeAll, mapProducts, transcript, printTarget, join$ = [].join;
  TreeModel = require('tree-model');
  debug = require('debug')('tree');
  uid = require('uid');
  _ = require('lodash');
  tree = new TreeModel();
  emptyNode = function(){
    return tree.parse({});
  };
  treeBuilder = (function(){
    treeBuilder.displayName = 'treeBuilder';
    var prototype = treeBuilder.prototype, constructor = treeBuilder;
    function treeBuilder(){
      this.parse = bind$(this, 'parse', prototype);
      this.collectSeq = bind$(this, 'collectSeq', prototype);
      this.collect = bind$(this, 'collect', prototype);
      this._collect = bind$(this, '_collect', prototype);
      this.processFiles = bind$(this, 'processFiles', prototype);
      this.compileFiles = bind$(this, 'compileFiles', prototype);
      this.createTree = bind$(this, 'createTree', prototype);
      this.curNode = emptyNode();
      this.curNode.model.targetName = "root";
      this.curNode.model.type = "root";
    }
    prototype.createTree = function(body){
      var newNode, savedCurNode;
      newNode = emptyNode();
      savedCurNode = this.curNode;
      this.curNode = newNode;
      body.apply(this, [this]);
      this.curNode = savedCurNode;
      debug(newNode);
      newNode.model.children = newNode.children.map(function(it){
        return it.model;
      });
      return newNode;
    };
    prototype.compileFiles = function(cmd, product, src, deps){
      src = [src];
      return this.curNode.addChild(tree.parse({
        cmdFun: cmd,
        productFun: product,
        src: src,
        deps: deps,
        targetName: "c-" + uid(8),
        type: "compile",
        children: []
      }));
    };
    prototype.processFiles = function(cmd, product, body){
      var root;
      root = this.createTree(body);
      _.extend(root.model, {
        cmdFun: cmd,
        productFun: product,
        targetName: "p-" + uid(8),
        type: "process"
      });
      return this.curNode.addChild(root);
    };
    prototype._collect = function(name, body, options){
      var root;
      debug("Creating " + name);
      root = this.createTree(body);
      _.extend(root.model, {
        targetName: name,
        options: options,
        type: "collect"
      });
      return this.curNode.addChild(root);
    };
    prototype.collect = function(name, body){
      return this._collect(name, body, {});
    };
    prototype.collectSeq = function(name, body){
      return this._collect(name, body, {
        sequential: true
      });
    };
    prototype.parse = function(body){
      this.curNode = this.createTree(body);
      return _.extend(this.curNode.model, {
        targetName: "root",
        type: "root"
      });
    };
    return treeBuilder;
  }());
  parse = function(body){
    var tb;
    tb = new treeBuilder();
    tb.parse(body);
    return tb.curNode;
  };
  removeFirst = function(root, condition){
    var x, father, i$, ref$, len$, c;
    x = root.first(condition);
    if (x != null && x.model.targetName !== root.targetName) {
      father = x.parent;
      for (i$ = 0, len$ = (ref$ = x.children).length; i$ < len$; ++i$) {
        c = ref$[i$];
        father.addChild(c);
      }
      x.drop();
      return true;
    } else {
      return false;
    }
  };
  removeAll = function(root, condition){
    var results$ = [];
    do {
      results$.push(null);
    } while (removeFirst(root, condition));
    return results$;
  };
  mapProducts = function(r){
    return r.walk({
      strategy: 'post'
    }, function(node){
      var products;
      products = [];
      return (function(){
        var s, cproducts;
        if (this.type === "compile") {
          return this.products = (function(){
            var i$, ref$, len$, results$ = [];
            for (i$ = 0, len$ = (ref$ = this.src).length; i$ < len$; ++i$) {
              s = ref$[i$];
              results$.push(this.productFun({
                source: s
              }));
            }
            return results$;
          }.call(this));
        } else {
          if (this.type === "process") {
            cproducts = _.flatten(this.children.map(function(it){
              return it.products;
            }));
            return this.products = (function(){
              var i$, ref$, len$, results$ = [];
              for (i$ = 0, len$ = (ref$ = _.flatten(this.children.map(fn$))).length; i$ < len$; ++i$) {
                s = ref$[i$];
                results$.push(this.productFun({
                  source: s
                }));
              }
              return results$;
              function fn$(it){
                return it.products;
              }
            }.call(this));
          } else {
            if (this.type === "root") {
              cproducts = _.flatten(this.children.map(function(it){
                return it.products;
              }));
              return this.products = cproducts;
            }
          }
        }
      }.call(node.model));
    });
  };
  transcript = function(r){
    removeAll(r, function(n){
      return n.model.type === "collect";
    });
    mapProducts(r);
    return r.walk({
      strategy: 'post'
    }, function(node){
      return console.log(printTarget(node));
    });
  };
  printTarget = function(node){
    return (function(){
      return " \n" + this.targetName + " [ " + this.type + " ] depends on " + join$.call(this.children.map(function(it){
        return it.targetName;
      }), ' ') + " - products " + join$.call(this.products, ',');
    }.call(node.model));
  };
  module.exports = {
    parse: parse,
    transcript: transcript
  };
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
}).call(this);
